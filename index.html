<!DOCTYPE html>
<html>

<head>
    <title>UV</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    
</head>

<body>
    <!-- core three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>



    <script>

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // ✅ เปิดใช้งานเงา!
        //ลดความเข้มสี(2บรรทัด)
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // tone mapping ที่ดูสมจริง
        renderer.toneMappingExposure = 0.8; // ลดความสว่าง
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        const exrLoader = new THREE.EXRLoader();
        exrLoader.load('https://trakanta4556.github.io/comgraph_project/kiara_1_dawn_2k.exr', function (texture) {
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;

        scene.environment = envMap;
        scene.background = envMap;

        texture.dispose();
        pmremGenerator.dispose();
        });


        const scene = new THREE.Scene();

        // --- Raycaster & interaction state ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const interactables = []; // เก็บ mesh ที่สามารถคลิกได้ (เช่น sign_about_me)
        let needsPick = false;
        let highlighted = null;

        // camera move/tween state
        const cameraMove = {
            active: false,
            fromPos: new THREE.Vector3(),
            toPos: new THREE.Vector3(),
            fromTarget: new THREE.Vector3(),
            toTarget: new THREE.Vector3(),
            startTime: 0,
            duration: 1.0
        };

        // เก็บ reference ของ text_name เพื่อให้กล้องมองเมื่อกดปุ่ม
        let textNameTarget = null;
        let textCreditBuildingTarget = null; 
        let textCreditDecorationTarget = null;
        let textCreditTreeTarget = null;
        let textCreditOceanTarget = null; 

        // ✅ กล้อง
        const camera = new THREE.PerspectiveCamera(
            35,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(1, 6.5, 50);
        camera.lookAt(0, 0, 0);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);      
        const ambientLight = new THREE.AmbientLight(0xFFF9A1, 0.1); // แสงสว่างทั่วไป
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.2); // แสงทิศทาง
        directionalLight.position.set(10, 5, 10);
        directionalLight.castShadow = true; // ✅ แสงนี้สร้างเงา
        scene.add(directionalLight);

        //ไฟ
        const pointLight = new THREE.PointLight(0xE9967A, 0.15, 2); //สี, ความเข้ม
        pointLight.position.set(2, 2, 1);
        pointLight.castShadow = true;
        scene.add(pointLight);
        
        //load model gate
        const gate = new THREE.GLTFLoader();
        gate.load('https://trakanta4556.github.io/comgraph_project/gate.glb', function(gltf) {
        const gate = gltf.scene;
        gate.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(gate);
    });    
        //load model bridge1
        const bridge1 = new THREE.GLTFLoader();
        bridge1.load('https://trakanta4556.github.io/comgraph_project/bridge1.glb', function(gltf) {
        const bridge1 = gltf.scene;
        bridge1.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(bridge1);
    });

    //load model boat
        const boat = new THREE.GLTFLoader();
        boat.load('https://trakanta4556.github.io/comgraph_project/boat.glb', function(gltf) {
        const boat = gltf.scene;
        boat.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(boat);
    });

    //load model text_name
        const text_name = new THREE.GLTFLoader();
        text_name.load('https://trakanta4556.github.io/comgraph_project/text_name.glb', function(gltf) {
        const text_name = gltf.scene;
        text_name.name = 'text_name';
        const targetPos = new THREE.Vector3();
        text_name.getWorldPosition(targetPos);
        console.log('Text Position:', targetPos);
        text_name.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(text_name);
        // เก็บ reference ของตำแหน่งสำหรับกล้องไปมอง
        textNameTarget = text_name;
    });

    //load model pic
        const pic = new THREE.GLTFLoader();
        pic.load('https://trakanta4556.github.io/comgraph_project/pic.glb', function(gltf) {
        const pic = gltf.scene;
        pic.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(pic);
    });

    //load model tree_boat
        const tree_boat = new THREE.GLTFLoader();
        tree_boat.load('https://trakanta4556.github.io/comgraph_project/tree_boat.glb', function(gltf) {
        const tree_boat = gltf.scene;
        tree_boat.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(tree_boat);
    });

    //load model temple
        const temple = new THREE.GLTFLoader();
        temple.load('https://trakanta4556.github.io/comgraph_project/temple.glb', function(gltf) {
        const temple = gltf.scene;
        temple.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(temple);
    });

    //load model tree_temple
        const tree_temple = new THREE.GLTFLoader();
        tree_temple.load('https://trakanta4556.github.io/comgraph_project/tree_temple.glb', function(gltf) {
        const tree_temple = gltf.scene;
        tree_temple.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(tree_temple);
    });

    //load model well
        const well = new THREE.GLTFLoader();
        well.load('https://trakanta4556.github.io/comgraph_project/well.glb', function(gltf) {
        const well = gltf.scene;
        well.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(well);
    });

    //load model bridge2
        const bridge2 = new THREE.GLTFLoader();
        bridge2.load('https://trakanta4556.github.io/comgraph_project/bridge2.glb', function(gltf) {
        const bridge2 = gltf.scene;
        bridge2.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(bridge2);
    });

    //load model tree_well2
        const tree_well2 = new THREE.GLTFLoader();
        tree_well2.load('https://trakanta4556.github.io/comgraph_project/tree_well2.glb', function(gltf) {
        const tree_well2 = gltf.scene;
        tree_well2.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(tree_well2);
    });

    //load model tree_well1
        const tree_well1 = new THREE.GLTFLoader();
        tree_well1.load('https://trakanta4556.github.io/comgraph_project/tree_well1.glb', function(gltf) {
        const tree_well1 = gltf.scene;
        tree_well1.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(tree_well1);
    });

    //load model house
        const house = new THREE.GLTFLoader();
        house.load('https://trakanta4556.github.io/comgraph_project/house.glb', function(gltf) {
        const house = gltf.scene;
        house.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(house);
    });

    //load model tree_house_left
        const tree_house_left = new THREE.GLTFLoader();
        tree_house_left.load('https://trakanta4556.github.io/comgraph_project/tree_house_left.glb', function(gltf) {
        const tree_house_left = gltf.scene;
        tree_house_left.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(tree_house_left);
    });

    //load model tree_house_right
        const tree_house_right = new THREE.GLTFLoader();
        tree_house_right.load('https://trakanta4556.github.io/comgraph_project/tree_house_right.glb', function(gltf) {
        const tree_house_right = gltf.scene;
        tree_house_right.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(tree_house_right);
    });

    //load model tea_table
    const tea_table = new THREE.GLTFLoader();
    tea_table.load('https://trakanta4556.github.io/comgraph_project/tea_table.glb', function(gltf) {
        const tea_table = gltf.scene;
        tea_table.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(tea_table);
    });

    //load model plane
        const plane = new THREE.GLTFLoader();
        plane.load('https://trakanta4556.github.io/comgraph_project/plane.glb', function(gltf) {
        const plane = gltf.scene;
        plane.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(plane);
    });

    //load model mirror
        const mirror = new THREE.GLTFLoader();
        mirror.load('https://trakanta4556.github.io/comgraph_project/mirror.glb', function(gltf) {
        const mirror = gltf.scene;
        mirror.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(mirror);
    });

    //load model text_credit_building
        const text_credit_building = new THREE.GLTFLoader();
        text_credit_building.load('https://trakanta4556.github.io/comgraph_project/text_credit_building.glb', function(gltf) {
            const text_credit_building = gltf.scene;
            text_credit_building.name = 'text_credit_building'; // <-- ตั้งชื่อเพื่อค้นหา/debug
            text_credit_building.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }   
            });
            scene.add(text_credit_building);
            textCreditBuildingTarget = text_credit_building; // <-- เก็บ reference
        });

        //load model text_back_credit_building
        const text_back_credit_building = new THREE.GLTFLoader();
        text_back_credit_building.load('https://trakanta4556.github.io/comgraph_project/text_back_credit_building.glb', function(gltf) {
            const text_back_credit_building = gltf.scene;
            text_back_credit_building.name = 'text_back_credit_building';
            text_back_credit_building.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    // ให้กดแล้วไปที่ credit decoration
                    child.userData.pickable = true;
                    child.userData.action = 'goto_text_credit_decoration';
                    interactables.push(child);
                }
            });
            scene.add(text_back_credit_building);
            // ถ้าต้องการเก็บ reference เพื่อ debug/ใช้อื่น ให้ตั้งค่า (ไม่บังคับ)
            textCreditBuildingTarget = text_back_credit_building;
        });

        //load model text_next_credit_building
        const text_next_credit_building = new THREE.GLTFLoader();
        text_next_credit_building.load('https://trakanta4556.github.io/comgraph_project/text_next_credit_building.glb', function(gltf) {
            const text_next_credit_building = gltf.scene;
            text_next_credit_building.name = 'text_next_credit_building';
            text_next_credit_building.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    // ให้กดแล้วไปที่ credit tree
                    child.userData.pickable = true;
                    child.userData.action = 'goto_text_credit_tree';
                    interactables.push(child);
                }
            });
            scene.add(text_next_credit_building);
            // ถ้าต้องการเก็บ reference เพื่อ debug/ใช้อื่น ให้ตั้งค่า (ไม่บังคับ)
            textCreditBuildingTarget = text_next_credit_building;
        });

        //load model text_credit_decoration
        const text_credit_decoration = new THREE.GLTFLoader();
        text_credit_decoration.load('https://trakanta4556.github.io/comgraph_project/text_credit_decoration.glb', function(gltf) {
            const text_credit_decoration = gltf.scene;
            text_credit_decoration.name = 'text_credit_decoration';
            text_credit_decoration.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }   
            });
            scene.add(text_credit_decoration);
            textCreditDecorationTarget = text_credit_decoration; // <-- เก็บ reference
        });

    //load model text_back_credit_decor
        const text_back_credit_decor = new THREE.GLTFLoader();
        text_back_credit_decor.load('https://trakanta4556.github.io/comgraph_project/text_back_credit_decor.glb', function(gltf) {
        const text_back_credit_decor = gltf.scene;
        text_back_credit_decor.name = 'text_back_credit_decor';
        text_back_credit_decor.traverse(function(child) {
        if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            // ทำให้เลือกได้และตั้ง action เป็นกลับไปที่ home (goto_home)
            child.userData.pickable = true;
            child.userData.action = 'goto_home';
            interactables.push(child);
        }   
        });
        scene.add(text_back_credit_decor);
    });

    //load model text_next_credit_decor
    const text_next_credit_decor = new THREE.GLTFLoader();
    text_next_credit_decor.load('https://trakanta4556.github.io/comgraph_project/text_next_credit_decor.glb', function(gltf) {
        const text_next_credit_decor = gltf.scene;
        text_next_credit_decor.name = 'text_next_credit_decor';
        text_next_credit_decor.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // ทำให้เลือกได้ และเมื่อกดให้ไปที่ text_credit_building
                child.userData.pickable = true;
                child.userData.action = 'goto_text_credit_building';
                interactables.push(child);
            }
        });
        scene.add(text_next_credit_decor);
    });

    //load model text_credit_tree
        const text_credit_tree = new THREE.GLTFLoader();
        text_credit_tree.load('https://trakanta4556.github.io/comgraph_project/text_credit_tree.glb', function(gltf) {
        const text_credit_tree = gltf.scene;
        text_credit_tree.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(text_credit_tree);
        textCreditTreeTarget = text_credit_tree; // <-- เก็บ reference ที่นี่
    });

    //load model text_back_credit_tree
    const text_back_credit_tree = new THREE.GLTFLoader();
    text_back_credit_tree.load('https://trakanta4556.github.io/comgraph_project/text_back_credit_tree.glb', function(gltf) {
        const text_back_credit_tree = gltf.scene;
        text_back_credit_tree.name = 'text_back_credit_tree';
        text_back_credit_tree.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // ทำให้เลือกได้ และเมื่อกดให้ไปที่ text_credit_building
                child.userData.pickable = true;
                child.userData.action = 'goto_text_credit_building';
                interactables.push(child);
            }  
        });
        scene.add(text_back_credit_tree);
        textBackCreditTreeTarget = text_back_credit_tree; // <-- เก็บ reference ที่นี่
    });
    //load model text_next_credit_tree
    const text_next_credit_tree = new THREE.GLTFLoader();
    text_next_credit_tree.load('https://trakanta4556.github.io/comgraph_project/text_next_credit_tree.glb', function(gltf) {
        const text_next_credit_tree = gltf.scene;
        text_next_credit_tree.name = 'text_next_credit_tree';
        text_next_credit_tree.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // ทำให้เลือกได้ และเมื่อกดให้ไปที่ text_credit_building
                child.userData.pickable = true;
                child.userData.action = 'goto_text_credit_ocean';
                interactables.push(child);
            }  
        });
        scene.add(text_next_credit_tree);
        textNextCreditTreeTarget = text_next_credit_tree; // <-- เก็บ reference ที่นี่
    });

    //load model sign_about_me
        const sign_about_me = new THREE.GLTFLoader();
        sign_about_me.load('https://trakanta4556.github.io/comgraph_project/sign_about_me.glb', function(gltf) {
        const sign_about_me = gltf.scene;
        sign_about_me.traverse(function(child) {
            if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            // ทำให้เลือกได้ และกำหนด action
            child.userData.pickable = true;
            child.userData.action = 'goto_text_name';
            // ใส่ชื่อเพื่อ debug
            sign_about_me.name = sign_about_me.name || 'sign_about_me';
            // เก็บลง interactables
            interactables.push(child);
            }   
        });
        scene.add(sign_about_me);
    });

    //load model sign_credits
        const sign_credits = new THREE.GLTFLoader();
        sign_credits.load('https://trakanta4556.github.io/comgraph_project/sign_credits.glb', function(gltf) {
    const sign_credits = gltf.scene;
    sign_credits.traverse(function(child) {
        if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            // ทำให้เลือกได้และตั้ง action ไปยัง text_credit_decoration
            child.userData.pickable = true;
            child.userData.action = 'goto_text_credit_decoration'; // <-- เปลี่ยน action
            interactables.push(child); // <-- ลงทะเบียนสำหรับ raycast
        }   
        });
        scene.add(sign_credits);
    });

    //load text_back_name
        const text_back_name = new THREE.GLTFLoader();
        text_back_name.load('https://trakanta4556.github.io/comgraph_project/text_back_name.glb', function(gltf) {
        const text_back_name = gltf.scene;
        text_back_name.name = 'text_back_name';
        text_back_name.traverse(function(child) {
        if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            // mark pickable and set action to return camera
            child.userData.pickable = true;
            child.userData.action = 'goto_home';
            interactables.push(child);
        }  
        });
        scene.add(text_back_name);
    });

    //load model text_credit_ocean
        const text_credit_ocean = new THREE.GLTFLoader();
        text_credit_ocean.load('https://trakanta4556.github.io/comgraph_project/text_credit_ocean.glb', function(gltf) {
        const text_credit_ocean = gltf.scene;
        text_credit_ocean.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }   
        });
        scene.add(text_credit_ocean);
        textCreditOceanTarget = text_credit_ocean; // <-- เก็บ reference ที่นี่
    });

    //load model text_back_credit_ocean
        const text_back_credit_ocean = new THREE.GLTFLoader();
        text_back_credit_ocean.load('https://trakanta4556.github.io/comgraph_project/text_back_credit_ocean.glb', function(gltf) {
            const text_back_credit_ocean = gltf.scene;
            text_back_credit_ocean.name = 'text_back_credit_ocean';
            text_back_credit_ocean.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    // ให้กดแล้วไปที่ credit tree
                    child.userData.pickable = true;
                    child.userData.action = 'goto_text_credit_tree';
                    interactables.push(child);
                }
            });
            scene.add(text_back_credit_ocean);
        });

    //load model text_next_credit_ocean
    const text_next_credit_ocean = new THREE.GLTFLoader();
    text_next_credit_ocean.load('https://trakanta4556.github.io/comgraph_project/text_next_credit_ocean.glb', function(gltf) {
        const text_next_credit_ocean = gltf.scene;
        text_next_credit_ocean.name = 'text_next_credit_ocean';
        text_next_credit_ocean.traverse(function(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // mark pickable and set action to return camera
                child.userData.pickable = true;
                child.userData.action = 'goto_home';
                interactables.push(child);
            }
        });
        scene.add(text_next_credit_ocean);
    });

    //load water plane 
    const uniforms = { 
    uTime: { value: 0.0 } ,
    uHeight: { value: null }, // texture ที่จะโหลดมา
    uDeep: { value: new THREE.Color(0x385D8D) }, // deep blue (for valleys)
    uHigh: { value: new THREE.Color(0xB2E4FF) }, // light blue (for peaks)
    uContrast: { value: 1.0 }
  };
    // pan offset and animation controls
    uniforms.uOffset = { value: new THREE.Vector2(0.0, 0.0) };
    uniforms.uAmplitude = { value: 0.12 }; // vertical wave amplitude
    uniforms.uSpeed = { value: 1.5 }; // speed multiplier for time
    uniforms.uFreq = { value: 12.0 }; // how strongly height modulates phase
    // ---- Shaders (sample texture ใน vertex แล้วดัน pos.z) ----
    const vert = `
        uniform sampler2D uHeight;
        uniform float uTime; //sinc animation

        // pan offset for sampling heightmap
        uniform vec2 uOffset;

    // animation controls
    uniform float uAmplitude;
    uniform float uSpeed;
    uniform float uFreq;

        varying float vH;

        void main(){
        vec3 pos = position;
        // float h = texture2D(uHeight, uv).r* sin(uTime)+0.5; 
    float h = texture2D(uHeight, uv + uOffset).r;
    // base displacement from heightmap
    pos.z = pos.z + (h * 0.8);
    // add time-based vertical animation modulated by height
    float wave = sin(uTime * uSpeed + h * uFreq) * uAmplitude;
    pos.z += wave;
        vH = h;                             
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    `;
    const frag = `
        precision mediump float;
        uniform vec3 uDeep;
        uniform vec3 uHigh;
        uniform float uContrast;
        uniform vec2 uOffset;
        varying float vH;
        void main(){
        // map vH [0,1] to [0,1] with simple contrast control
        float t = clamp(vH, 0.0, 1.0);
        // simple contrast: remap around 0.5
        t = (t - 0.5) * uContrast + 0.5;
        t = clamp(t, 0.0, 1.0);
        vec3 color = mix(uDeep, uHigh, t);
        gl_FragColor = vec4(color, 1.0);
        }
    `;

    // โหลด texture แล้วค่อยสร้าง geometry/material ให้สัดส่วนตรงกับรูป
    new THREE.TextureLoader().load('https://upload.wikimedia.org/wikipedia/commons/5/57/Heightmap.png', (tex) => {

        uniforms.uHeight.value = tex;
        const geo = new THREE.PlaneBufferGeometry(70, 70, 200, 200);
        const mat = new THREE.ShaderMaterial({
        vertexShader: vert,
        fragmentShader: frag,
        uniforms: uniforms,
        //wireframe: true, // เปิดถ้าอยากดูเส้นตาราง
        side: THREE.DoubleSide
        
        });

        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2; // หมุน plane แนวราบ
        mesh.position.y = -1; // ลดระดับลงนิดหน่อย
        scene.add(mesh);
    });
    

    // Resize
    addEventListener('resize', ()=>{ 
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    // pointer handlers
    window.addEventListener('pointermove', (e) => {
        pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
        needsPick = true;
    });

    window.addEventListener('click', (e) => {
        // ensure pointer matches this click (in case user didn't move mouse)
        pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;

        // raycast on click
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(interactables, true);
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (obj.userData && obj.userData.action === 'goto_text_name' && textNameTarget) {
                // compute bounding center & size of text_name
                const bbox = new THREE.Box3().setFromObject(textNameTarget);
                const targetPos = new THREE.Vector3();
                bbox.getCenter(targetPos);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const radius = Math.max(size.length() * 0.5, 0.5);

                // choose view parameters (ปรับค่าเหล่านี้เพื่อเปลี่ยนมุม/ระยะ)
                const distance = Math.max(6, radius * 4.5); // ระยะจาก target
                const elevationDeg = 10; // ความสูงมุมมอง (องศา)
                const azimuthDeg = -18; // หมุนรอบแกน Y (องศา) เปลี่ยนเป็น 45 เพื่อมุมเฉียง

                const phi = THREE.Math.degToRad(azimuthDeg);
                const theta = THREE.Math.degToRad(elevationDeg);

                // offset vector จากมุม (world space)
                const offset = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(theta),
                    Math.cos(phi) * Math.cos(theta)
                ).multiplyScalar(distance);

                const toPos = targetPos.clone().add(offset);

                // start camera tween
                cameraMove.active = true;
                cameraMove.fromPos.copy(camera.position);
                cameraMove.toPos.copy(toPos);
                cameraMove.fromTarget.copy(controls.target);
                cameraMove.toTarget.copy(targetPos);
                cameraMove.startTime = performance.now() / 1000;
                cameraMove.duration = 1.5; // วินาที
            } else if (obj.userData && obj.userData.action === 'goto_text_credit_building' && textCreditBuildingTarget) {
                // compute bounding center & size of text_credit_building
                const bbox = new THREE.Box3().setFromObject(textCreditBuildingTarget);
                const targetPos = new THREE.Vector3();
                bbox.getCenter(targetPos);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const radius = Math.max(size.length() * 0.5, 0.5);

                // choose view parameters (ปรับค่าเหล่านี้เพื่อเปลี่ยนมุม/ระยะ)
                const distance = Math.max(6, radius * 4.5); // ระยะจาก target
                const elevationDeg = 50; // ความสูงมุมมอง (องศา)
                const azimuthDeg = 100; // หมุนรอบแกน Y (องศา) เปลี่ยนเป็น 45 เพื่อมุมเฉียง

                const phi = THREE.Math.degToRad(azimuthDeg);
                const theta = THREE.Math.degToRad(elevationDeg);

                // offset vector จากมุม (world space)
                const offset = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(theta),
                    Math.cos(phi) * Math.cos(theta)
                ).multiplyScalar(distance);

                const toPos = targetPos.clone().add(offset);

                // start camera tween
                cameraMove.active = true;
                cameraMove.fromPos.copy(camera.position);
                cameraMove.toPos.copy(toPos);
                cameraMove.fromTarget.copy(controls.target);
                cameraMove.toTarget.copy(targetPos);
                cameraMove.startTime = performance.now() / 1000;
                cameraMove.duration = 1.5; // วินาที
            } else if (obj.userData && obj.userData.action === 'goto_text_credit_decoration' && textCreditDecorationTarget) {
                // compute bounding center & size of text_credit_decoration
                const bbox = new THREE.Box3().setFromObject(textCreditDecorationTarget);
                const targetPos = new THREE.Vector3();
                bbox.getCenter(targetPos);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const radius = Math.max(size.length() * 0.5, 0.5);

                // ปรับมุม/ระยะ: เพิ่ม azimuth ให้ไปทางขวา และเพิ่ม elevation ให้กล้องสูงขึ้น
                const distance = Math.max(6, radius * 4); // ปรับถ้าต้องการถอย/เข้า
                const elevationDeg = 48; // เพิ่มค่านี้เพื่อให้กล้องสูงขึ้น
                const azimuthDeg = 9.5;   // ค่า + เป็นเลื่อนมาทางขวา (ปรับเป็นลบถ้าต้องการซ้าย)

                const phi = THREE.Math.degToRad(azimuthDeg);
                const theta = THREE.Math.degToRad(elevationDeg);

                // offset vector จากมุม (world space)
                const offset = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(theta),
                    Math.cos(phi) * Math.cos(theta)
                ).multiplyScalar(distance);

                const toPos = targetPos.clone().add(offset);

                // start camera tween
                cameraMove.active = true;
                cameraMove.fromPos.copy(camera.position);
                cameraMove.toPos.copy(toPos);
                cameraMove.fromTarget.copy(controls.target);
                cameraMove.toTarget.copy(targetPos);
                cameraMove.startTime = performance.now() / 1000;
                cameraMove.duration = 1.5; // ปรับความเร็ว
            } else if (obj.userData && obj.userData.action === 'goto_home') {
                // กลับไปมองตำแหน่ง homeTarget ด้วยมุมที่กำหนด
                const homeTarget = new THREE.Vector3(2, 3, 34); // จุดที่ให้กล้องมองถึง
                // ปรับมุมที่ต้องการเมื่อกด back (องศา)
                const azimuthDeg = -2;    // หมุนรอบแกน Y (ซ้าย/ขว)
                const elevationDeg = 7.5;    // มุมเอียงขึ้น/ลง
                const distance = 12.5;       // ระยะจาก target (ปรับเพื่อถอย/เข้า)

                const phi = THREE.Math.degToRad(azimuthDeg);
                const theta = THREE.Math.degToRad(elevationDeg);

                const offset = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(theta),
                    Math.cos(phi) * Math.cos(theta)
                ).multiplyScalar(distance);

                const toPos = homeTarget.clone().add(offset);

                cameraMove.active = true;
                cameraMove.fromPos.copy(camera.position);
                cameraMove.toPos.copy(toPos);
                cameraMove.fromTarget.copy(controls.target);
                cameraMove.toTarget.copy(homeTarget);
                cameraMove.startTime = performance.now() / 1000;
                cameraMove.duration = 1.5;
            } else if (obj.userData && obj.userData.action === 'goto_text_credit_tree' && textCreditTreeTarget) {
                // compute bounding center & size of text_credit_tree
                const bbox = new THREE.Box3().setFromObject(textCreditTreeTarget);
                const targetPos = new THREE.Vector3();
                bbox.getCenter(targetPos);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const radius = Math.max(size.length() * 0.5, 0.5);

                // ปรับมุม/ระยะ: เพิ่ม azimuth ให้ไปทางขวา และเพิ่ม elevation ให้กล้องสูงขึ้น
                const distance = Math.max(6, radius * 2.8); // ปรับถ้าต้องการถอย/เข้า
                const elevationDeg = 38; // เพิ่มค่านี้เพื่อให้กล้องสูงขึ้น
                const azimuthDeg = 135.5;   // ค่า + เป็นเลื่อนมาทางขวา (ปรับเป็นลบถ้าต้องการซ้าย)

                const phi = THREE.Math.degToRad(azimuthDeg);
                const theta = THREE.Math.degToRad(elevationDeg);

                // offset vector จากมุม (world space)
                const offset = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(theta),
                    Math.cos(phi) * Math.cos(theta)
                ).multiplyScalar(distance);

                const toPos = targetPos.clone().add(offset);

                // start camera tween
                cameraMove.active = true;
                cameraMove.fromPos.copy(camera.position);
                cameraMove.toPos.copy(toPos);
                cameraMove.fromTarget.copy(controls.target);
                cameraMove.toTarget.copy(targetPos);
                cameraMove.startTime = performance.now() / 1000;
                cameraMove.duration = 1.5; // ปรับความเร็ว
            }else if (obj.userData && obj.userData.action === 'goto_text_credit_ocean' && textCreditOceanTarget) {
                // compute bounding center & size of text_credit_ocean
                const bbox = new THREE.Box3().setFromObject(textCreditOceanTarget);
                const targetPos = new THREE.Vector3();
                bbox.getCenter(targetPos);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const radius = Math.max(size.length() * 0.5, 0.5);

                // ปรับมุม/ระยะ: เพิ่ม azimuth ให้ไปทางขวา และเพิ่ม elevation ให้กล้องสูงขึ้น
                const distance = Math.max(6, radius * 3); // ปรับถ้าต้องการถอย/เข้า
                const elevationDeg = 28; // เพิ่มค่านี้เพื่อให้กล้องสูงขึ้น
                const azimuthDeg = -45;   // ค่า + เป็นเลื่อนมาทางขวา (ปรับเป็นลบถ้าต้องการซ้าย)

                const phi = THREE.Math.degToRad(azimuthDeg);
                const theta = THREE.Math.degToRad(elevationDeg);

                // offset vector จากมุม (world space)
                const offset = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(theta),
                    Math.cos(phi) * Math.cos(theta)
                ).multiplyScalar(distance);

                const toPos = targetPos.clone().add(offset);

                // start camera tween
                cameraMove.active = true;
                cameraMove.fromPos.copy(camera.position);
                cameraMove.toPos.copy(toPos);
                cameraMove.fromTarget.copy(controls.target);
                cameraMove.toTarget.copy(targetPos);
                cameraMove.startTime = performance.now() / 1000;
                cameraMove.duration = 1.5; // ปรับความเร็ว
            }
        }
    });

    // highlight on hover (optional)
    function applyHighlight(obj) {
        if (!obj) return;
        const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
        mats.forEach(m => {
            if (!m) return;
            if (m.emissive !== undefined) {
                if (obj.userData._origEmissive === undefined) obj.userData._origEmissive = m.emissive.getHex();
                m.emissive.setHex(0x333333);
            } else if (m.color) {
                if (obj.userData._origColor === undefined) obj.userData._origColor = m.color.getHex();
                m.color.setHex(0x8899ff);
            }
        });
    }
    function clearHighlight(obj) {
        if (!obj) return;
        const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
        mats.forEach(m => {
            if (!m) return;
            if (m.emissive !== undefined && obj.userData._origEmissive !== undefined) {
                m.emissive.setHex(obj.userData._origEmissive);
            } else if (m.color && obj.userData._origColor !== undefined) {
                m.color.setHex(obj.userData._origColor);
            }
        });
        delete obj.userData._origEmissive;
        delete obj.userData._origColor;
    }

    // unified animate
    const clock = new THREE.Clock(); // ถ้ามาประกาศก่อนแล้ว ให้ใช้ของเดิม
    let mixer = window.mixer || undefined; // ถ้ามี loader สร้าง mixer ให้กำหนด mixer หลังโหลด

    // — โหลดโมเดล GLB ที่มี animation
    const loader = new THREE.GLTFLoader();
    loader.load('https://trakanta4556.github.io/comgraph_project/animationglb.glb',(gltf) => {
        console.log("✅ GLB loaded", gltf);
        const model = gltf.scene;
        scene.add(model);

        if (gltf.animations && gltf.animations.length > 0) {
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
            console.log("Animation clip:", clip.name, "duration:", clip.duration);
            const action = mixer.clipAction(clip);
            action.play();
            });
        } 
        }
    );


    function animate() {
        const delta = clock.getDelta();
        // update animation mixer
        if (mixer) mixer.update(delta);

        // update water shader time (เดิมเพิ่มค่า)
        if (typeof uniforms !== 'undefined' && uniforms.uTime) {
            uniforms.uTime.value += 0.04;
        }

        // handle picking highlight (throttled by animation frame)
        if (needsPick) {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(interactables, true);
            const first = intersects.length ? intersects[0].object : null;
            if (first !== highlighted) {
                if (highlighted) clearHighlight(highlighted);
                highlighted = first;
                if (highlighted) applyHighlight(highlighted);
            }
            needsPick = false;
        }

        // handle camera movement tween
        if (cameraMove.active) {
            const now = performance.now() / 1000;
            const t = (now - cameraMove.startTime) / cameraMove.duration;
            const tt = Math.min(Math.max(t, 0), 1);
            camera.position.lerpVectors(cameraMove.fromPos, cameraMove.toPos, tt);
            controls.target.lerpVectors(cameraMove.fromTarget, cameraMove.toTarget, tt);
            controls.update();
            if (tt >= 1) cameraMove.active = false;
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    </script>
</body>

</html>
